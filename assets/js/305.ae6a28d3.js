(window.webpackJsonp=window.webpackJsonp||[]).push([[305],{776:function(_,v,o){"use strict";o.r(v);var l=o(62),d=Object(l.a)({},(function(){var _=this,v=_.$createElement,o=_._self._c||v;return o("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[o("h1",{attrs:{id:"undo-log-和-redo-log"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#undo-log-和-redo-log"}},[_._v("#")]),_._v(" undo-log 和 redo-log")]),_._v(" "),o("p",[_._v("在数据库系统"),o("small",[_._v("（DBMS）")]),_._v("中，磁盘上除了有存放数据的文件之外，还有存放日志的文件。通常"),o("small",[_._v("（从优化的角度）")]),_._v("，数据库的日志信息都是先存储在内存的缓存中，随后再异步地存储到磁盘上。")]),_._v(" "),o("p",[_._v("MySQL 中的日志文件，有 2 种与『事务』有关："),o("strong",[_._v("undo")]),_._v(" 日志和 "),o("strong",[_._v("redo")]),_._v(" 日志。"),o("small",[_._v("也称为，undo-log 和 redo-log 。")])]),_._v(" "),o("h2",{attrs:{id:"_1-undo-log"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_1-undo-log"}},[_._v("#")]),_._v(" 1. undo log")]),_._v(" "),o("p",[_._v("在对数据库执行增删改操作前，MySQL 会将变动前的数据"),o("small",[_._v("（即原始数据）")]),_._v("先备份到 undo log，然后再进行数据库。这样，未来在出错需要回滚的时候，就可以利用 undo log 中备份的数据进行数据的回滚。")]),_._v(" "),o("p",[_._v("在 undo log 的参与下，数据库的操作流程如下：")]),_._v(" "),o("ol",[o("li",[_._v("事务开始；")]),_._v(" "),o("li",[_._v("记录 "),o("code",[_._v("A=100")]),_._v(" 到 undo log"),o("small",[_._v("（内存缓存中）")])]),_._v(" "),o("li",[_._v("修改 "),o("code",[_._v("A=200")]),o("small",[_._v("（内存中）")])]),_._v(" "),o("li",[_._v("将 undo log 写入到磁盘")]),_._v(" "),o("li",[_._v("将 "),o("code",[_._v("A=200")]),_._v(" 写入到磁盘")]),_._v(" "),o("li",[_._v("提交事务")])]),_._v(" "),o("p",[o("strong",[_._v("undo log 的存在保证了事务的一致性。")])]),_._v(" "),o("ul",[o("li",[_._v("如果包括 "),o("code",[_._v("4")]),_._v(" 在内的之前的操作执行失败，整个事务算执行失败，并且对 MySQL 的并没有影响，因为截止目前为止的改动都是记录在内存中的，并未影响到磁盘。")]),_._v(" "),o("li",[_._v("如果 "),o("code",[_._v("5")]),_._v(" 或 "),o("code",[_._v("6")]),_._v(" 执行失败，MySQL 会利用 "),o("code",[_._v("4")]),_._v(" 中存盘的 undo log 进行数据恢复。")])]),_._v(" "),o("h2",{attrs:{id:"_2-redo-log"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_2-redo-log"}},[_._v("#")]),_._v(" 2. redo log")]),_._v(" "),o("p",[_._v("redo log 和 undo log 相反，redo log 中记录的是经过你变动之后的数据。")]),_._v(" "),o("p",[_._v("在 redo log 的参与下，数据库的操作流程如下：")]),_._v(" "),o("ol",[o("li",[_._v("事务开始：")]),_._v(" "),o("li",[_._v("记录 "),o("code",[_._v("A=100")]),_._v(" 到 undo log"),o("small",[_._v("（内存缓存中）")])]),_._v(" "),o("li",[_._v("修改 "),o("code",[_._v("A=200")]),o("small",[_._v("（内存中）")])]),_._v(" "),o("li",[_._v("记录 "),o("code",[_._v("A=200")]),_._v(" 到 redo log"),o("small",[_._v("（内存缓存中）")])]),_._v(" "),o("li",[_._v("将 undo log 写入到磁盘")]),_._v(" "),o("li",[_._v("将 redo log 写入到磁盘")]),_._v(" "),o("li",[o("del",[_._v("将 "),o("code",[_._v("A=200")]),_._v(" 写入到磁盘")])]),_._v(" "),o("li",[_._v("提交事务")])]),_._v(" "),o("p",[_._v("虽然逻辑上本应该有 "),o("code",[_._v("6")]),_._v(" 这一步操作，但是从优化的角度考虑，MySQL 把这一步给省略掉了。原因在于：")]),_._v(" "),o("ul",[o("li",[_._v("MySQL 是用异步地方式将内存中的新数据（"),o("code",[_._v("A=200")]),_._v("）存储到磁盘的，因此，A=200 的数据的存盘反而是在 "),o("code",[_._v("7")]),_._v(" 执行之后。")]),_._v(" "),o("li",[_._v("由于 redo log 的存在，实际上，在执行 "),o("code",[_._v("5")]),_._v(" 之后，磁盘上已经持久化了新数据了。所以，未来，MySQL 从磁盘上的 redo log 中取新数据即可。")])])])}),[],!1,null,null,null);v.default=d.exports}}]);