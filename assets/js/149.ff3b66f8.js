(window.webpackJsonp=window.webpackJsonp||[]).push([[149],{621:function(v,_,t){"use strict";t.r(_);var l=t(62),n=Object(l.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"多线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多线程"}},[v._v("#")]),v._v(" 多线程")]),v._v(" "),t("p",[v._v("『线程』是更现代化的概念和技术"),t("small",[v._v("（它的诞生晚于进程）")]),v._v("。线程是『"),t("strong",[v._v("进程中")]),v._v("』的一个单位，即，一个进程可以有多个线程"),t("small",[v._v("（至少有一个），简单来说，就是 "),t("code",[v._v("一对多")]),v._v(" 的关系")]),v._v("。")]),v._v(" "),t("p",[v._v("线程是进程中执行运算的最小单元，一个进程在其执行过程中可以产生多个线程，而线程必须在某个进程内执行。")]),v._v(" "),t("p",[v._v("线程是进程内部的一个执行单元，是可以完成一个独立任务的顺序控制流程。如果在一个进程中同时运行了多个线程，用来完成不同的工作，则称之为『"),t("strong",[v._v("多线程")]),v._v("』。")]),v._v(" "),t("p",[v._v("线程和进程既有联系又有区别：")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("一个进程中至少要有一个线程；")])]),v._v(" "),t("li",[t("p",[v._v("操作系统将资源分配给进程，同一个进程的所有线程共享该进程的所有资源；")])]),v._v(" "),t("li",[t("p",[v._v("操作系统将 CPU 分配给线程，即真正在 CPU 上运行的上线程。")])])]),v._v(" "),t("p",[t("strong",[v._v("每个线程都有一个『执行方法』")]),t("small",[v._v("（也叫『"),t("strong",[v._v("入口方法")]),v._v("』）")]),v._v("，每个进程至少拥有的、自动拥有的那个线程的执行方法毫无疑问就是 "),t("strong",[v._v("main")]),v._v(" 方法，因此这个线程也被成为『"),t("strong",[v._v("主线程")]),v._v("』。")]),v._v(" "),t("p",[v._v("每个线程的任务、使命就是去执行它的执行方法。"),t("small",[v._v("线程的执行方法的结束，即意味着线程的生命、使命的完结。")])]),v._v(" "),t("p",[v._v("创建并使用线程的过程可以分为 4 个步骤：")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("定义一个线程类，同时指明这个线程的执行方法")])]),v._v(" "),t("li",[t("p",[v._v("创建线程对象")])]),v._v(" "),t("li",[t("p",[v._v("启动线程")])]),v._v(" "),t("li",[t("p",[v._v("终止线程")])])]),v._v(" "),t("p",[v._v("定义一个线程类通常有两种方法：继承 "),t("strong",[v._v("java.lang.Thread")]),v._v(" 类和实现 "),t("strong",[v._v("java.lang.Runnable")]),v._v(" 接口。")])])}),[],!1,null,null,null);_.default=n.exports}}]);