(window.webpackJsonp=window.webpackJsonp||[]).push([[117],{589:function(t,a,s){"use strict";s.r(a);var e=s(62),v=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"分支"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分支"}},[t._v("#")]),t._v(" 分支")]),t._v(" "),s("h2",{attrs:{id:"_1-关于分支"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-关于分支"}},[t._v("#")]),t._v(" 1. 关于分支")]),t._v(" "),s("p",[t._v("版本的提交不可能『依次进行，以便形成一条直线型的提交历史记录』，原因有二：")]),t._v(" "),s("ul",[s("li",[s("p",[s("strong",[t._v("并行式开发")]),t._v("：有两个以上的开发者在对同一个项目进行并行式开发。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("版本库 1            版本库2\nA <--- B <--- C     A <--- B <--- D\n\n         C\n        /\nA <--- B  \n        \\\n         D\n")])])])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("修复旧版本中的 bug")]),t._v("：一方面要修复旧版本中的 bug，而与此同时又要创建和发布新的版本。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("前期\nA <--- B <--- C <--- D\n\n修复 bug 之后\n         C <--- D\n        /\nA <--- B  \n        \\\n         E\n")])])])])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("有人将分支比喻成泳道")]),t._v(" "),s("p",[t._v("分支可以看作是开发过程当中的并行线，我们可以把提交图想象成游泳池中的泳道：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("         E              release\n        /\nA <--- B <--- C <--- D  master\n               \\\n                F       test\n")])])])]),t._v(" "),s("p",[t._v("在一个 Git 版本库中，总是唯一存在着一个『"),s("strong",[t._v("活动分支")]),t._v("』"),s("small",[t._v("（也叫『"),s("strong",[t._v("当前分支")]),t._v("』）")]),t._v("。我们可以用 "),s("strong",[t._v("branch")]),t._v(" 命令"),s("small",[t._v("（不带选项）")]),t._v("来列出所有的分支。Git 会用星号"),s("small",[t._v("（*）")]),t._v("凸显出当前活动分支。")]),t._v(" "),s("p",[t._v("在 GitKraken 中当前分支名字前面有一个 "),s("code",[t._v("✓")]),t._v(" 符号。")]),t._v(" "),s("h2",{attrs:{id:"_2-分支基本操作"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-分支基本操作"}},[t._v("#")]),t._v(" 2. 分支基本操作")]),t._v(" "),s("ul",[s("li",[s("p",[s("strong",[t._v("查看分支")])]),t._v(" "),s("p",[t._v("通过 "),s("strong",[t._v("git branch")]),t._v(" 可以看到 Git 仓库的所有分支。")]),t._v(" "),s("p",[t._v("当执行 git init 指令的时候，Git 就会自动产生一个名为 "),s("strong",[t._v("master")]),t._v(" 的分支：主分支。主分支是默认的、初始的。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("创建分支")])]),t._v(" "),s("p",[t._v("创建新的分支，也是使用 "),s("strong",[t._v("git branch")]),t._v(" 命令。")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" branch 新分支名 "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("从当前分支的 Commit"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n")])])]),s("p",[t._v("如果省略 Commit，那么就是从当前分支的 HEAD 分化出新分支。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("切换分支")])]),t._v(" "),s("p",[t._v("建立分支后，可以通过 "),s("strong",[t._v("git checkout")]),t._v(" 命令来切换当前分支：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("git checkout <分支名>\n")])])]),s("p",[t._v("有个简单的办法可以创建新分支并切换：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("git checkout -b <新分支名> [Commit节点]\n")])])]),s("p",[t._v("分支指针主要用于指向活动分支"),s("small",[t._v("（即它总是在当前分支上的）")]),t._v("，每次提交时，它会移动到最新提交上。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("删除分支")])]),t._v(" "),s("p",[t._v("删除分支使用：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("git branch -d <被删除分支名>\n")])])]),s("p",[t._v("如果在删除一个分支时，自己还未转移到其他分支上，git 会拒绝删除操作。如果坚持要删除的话，则使用 "),s("strong",[t._v("-D")]),t._v(" 选项替换 "),s("strong",[t._v("-d")]),t._v(" 选项。")]),t._v(" "),s("p",[t._v("一般情况下，分支应该合并到另一个分支。如果要删除还未合并的分支，Git 会显示错误信息，并拒绝删除。当然你也通过 "),s("strong",[t._v("-D")]),t._v(" 选项来强制删除。")])])]),t._v(" "),s("h2",{attrs:{id:"_3-分支合并"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-分支合并"}},[t._v("#")]),t._v(" 3. 分支合并")]),t._v(" "),s("p",[t._v("在大多数情况下，项目的分支都会被合并到主"),s("small",[t._v("（master）")]),t._v("分支。合并项目分支需要使用 "),s("strong",[t._v("git merge")]),t._v(" 命令：")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" merge "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("另一个分支名"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),s("p",[s("strong",[t._v("该命令会把『另一个分支』合并到当前分支，合并后的 Commit 属于当前分支。")])]),t._v(" "),s("div",{staticClass:"custom-block danger"},[s("p",{staticClass:"custom-block-title"},[t._v("你站在哪个分支上？当前分支是谁？")]),t._v(" "),s("p",[t._v("考虑这个问题的关键点在于：合并分支是合并 “进来” 。体会下，什么叫合 “进” 来。")]),t._v(" "),s("p",[t._v("假设是 A 和 B 两个分支合并，这里就有 2 种情况：")]),t._v(" "),s("ul",[s("li",[t._v("站在 A 分支上"),s("small",[t._v("（你的当前分支是 A ）")]),t._v("，把 B 分支合并 “进来” 。")]),t._v(" "),s("li",[t._v("站在 B 分支上"),s("small",[t._v("（你的当前分支是 B ）")]),t._v("，把 A 分支合并 “进来”。")])]),t._v(" "),s("p",[t._v("这 2 种情况都合情合理合法，关键是你要考虑清楚你需要到的是哪一种情况。")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("前期：\nA <--- B <--- E    master\n        \\\n         C <--- D  feature\n\n后期：\nA <--- B <--- E <--- F  master\n        \\           /\n         C <------ D  feature\n")])])]),s("p",[t._v("结合上面的那个问题，从图上"),s("small",[t._v("（合并的箭头方向）")]),t._v("可以看到，你是站在 master 分支上，把 feature 分支合并了 “进来” 。")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("回顾一下")]),t._v(" "),s("p",[t._v("如果合并后想反悔，那么可以执行之前所学的 "),s("code",[t._v("git reset --soft HEAD~1")]),t._v("，回到提交前夜，然后放弃提交。")])]),t._v(" "),s("p",[t._v("合并所产生的节点和普通节点有一个很重要的区别：")]),t._v(" "),s("ul",[s("li",[t._v("普通节点只有唯一的父节点，表示为 "),s("code",[t._v("HEAD^1")]),t._v(" ；")]),t._v(" "),s("li",[t._v("合并节点有 2 个父节点，分别表示为 "),s("code",[t._v("HEAD^1")]),t._v(" 和 "),s("code",[t._v("HEAD^2")]),t._v(" 。")])]),t._v(" "),s("h2",{attrs:{id:"_4-冲突"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-冲突"}},[t._v("#")]),t._v(" 4. 冲突")]),t._v(" "),s("p",[t._v("Git 的设计目标之一就是为了能够让开发者之间的分布式协作变得尽可能容易一些。因此从很大程度上来说，merge 命令能自动对分支进行合并，完全不需要用户交互。")]),t._v(" "),s("p",[t._v("当两个分支对于同一个文件做出了不同的操作时，可能会出现冲突，而且此时，Git 无法自动 “帮” 你合并。最常见的冲突情况有 2 种：")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("两个分支对于同一个文件的同一个位置做出了修改。")]),t._v(" "),s("p",[t._v("那么你在合并这两个分支时，Git 无法自己决定 “合并后保留的是哪个分支上的内容"),s("small",[t._v("（而废弃另一个）")]),t._v("，亦或者是两个分支上的都要保留” ？这种情况，就需要人来裁决。")])]),t._v(" "),s("li",[s("p",[t._v("一个分支对一个文件执行了删除操作，而另一个分支上这个文件还在，仅仅只是内容有变动。")]),t._v(" "),s("p",[t._v("那么你在合并这两个分支时，Git 无法自己决定 “合并后这个文件到底是应该删除，还是留着” ？这种情况也需要人来裁决。")])])]),t._v(" "),s("p",[t._v("补充一点，并非对于同一个文件的修改，都会造成冲突。比如，如果两个分支是对同一个文件的不同位置做出了修改"),s("small",[t._v("（注意和上述第一种情况的区别）")]),t._v("，Git 自己也会自动合并：合并后的内容会同时采纳两个分支上的操作。")]),t._v(" "),s("p",[t._v("当 Git 遇到了自身无法解决的冲突时，就会显示以下错误信息。")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[t._v("$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" merge a-branch\n\nAuto-merging foo.txt\nCONFLICT "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("content"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(": Merge conflict "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" foo.txt\nAutomatic merge failed"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" fix conflicts and "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("then")]),t._v(" commit the result.\n")])])]),s("p",[t._v("此时，如果执行 "),s("strong",[t._v("git status")]),t._v(" 命令，会看到 git 提醒你，它无法完成自动合并，需要你手动进行编辑，并且要求你在编辑之后，执行 "),s("strong",[t._v("git commit")]),t._v(" 。")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[t._v("$ "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" status\n\nOn branch master\nYou have unmerged paths.\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("fix conflicts and run "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"git commit"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\nUnmerged paths:\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("use "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"git add <file>..."')]),t._v(" to mark resolution"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n \nboth modified:   foo.txt\n \nno changes added to commit "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("use "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"git add"')]),t._v(" and/or "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"git commit -a"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("冲突标志通常会描述两组修改。首先这些被修改的行在当前分支（HEAD）中的内容。接下来又列出了他们在另外一个分支的内容，例如：")]),t._v(" "),s("div",{staticClass:"language-text extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("第一次修改\n第二次修改\n")])])]),s("p",[t._v("手动解决完冲突以后，运行 "),s("strong",[t._v("git add")]),t._v(" 命令把相关文件添加到暂存区。继续执行 "),s("strong",[t._v("git merge --continue")]),t._v(" 命令编辑新生成的提交的 log 信息。然后 merge 完成。")]),t._v(" "),s("p",[t._v("冲突和解决冲突示意图：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://hemiao3000.gitee.io/java-note-img/images/git/img/git-merge-4.gif",alt:"git-top-10-04"}})]),t._v(" "),s("h2",{attrs:{id:"_5-git-mergetool"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-git-mergetool"}},[t._v("#")]),t._v(" 5. git mergetool")]),t._v(" "),s("p",[t._v("如果配置了 "),s("strong",[t._v("git mergetool")]),t._v(" 那么，在 Git 告知你合并冲突后，通过 "),s("strong",[t._v("git mergetool")]),t._v(" 命令启动第三方合并工具，来进行图形化界面的操作。例如，Beyond Compare 或者是 VS Code 。")]),t._v(" "),s("p",[t._v("如果使用 VS Code 作为第三方合并工具，那么需要在 .gitconfig 中追加如下配置：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('[merge]\n  tool = vscode\n[mergetool "vscode"]\n  keepbackup = false\n  cmd = code --wait $MERGED\n  trustexitcode = true\n')])])]),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("个人建议")]),t._v(" "),s("p",[t._v("目前我个人比较倾向于使用 VS Code 作为辅助的合并工具。因为，一方面它能够让你直面合并文件的本质，另一方面，它提供了必要的快捷操作按钮。基本上同时兼具了 “本质” 和 “快捷” 两方面。")])]),t._v(" "),s("p",[t._v("vs code 作为 mergetool 的效果图:")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://hemiao3000.gitee.io/java-note-img/images/git/img/git-mergetool-01.png",alt:"git-mergetool-01.png"}})]),t._v(" "),s("h2",{attrs:{id:"_6-快速合并-git-merge-ff"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-快速合并-git-merge-ff"}},[t._v("#")]),t._v(" 6. 快速合并：git merge --ff")]),t._v(" "),s("h3",{attrs:{id:"关于快速合并"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关于快速合并"}},[t._v("#")]),t._v(" 关于快速合并")]),t._v(" "),s("p",[t._v("所谓的快速合并指的是在执行 git merge 命令时多带一个 "),s("code",[t._v("--ff")]),t._v(" 的参数，它是 Fast Forward 这两个单词的首字母。")]),t._v(" "),s("p",[t._v("有 “快速” 合并自然就有 “非快速” 合并："),s("code",[t._v("--no-ff")]),t._v(" 。")]),t._v(" "),s("p",[t._v("Git 在合并时的默认行为是：先看当前的情况是否符合快速合并的条件，如果符合就进行快速合并，否则就进行非快速合并。")]),t._v(" "),s("p",[t._v("当然，你可以通过强行指定 --no-ff 告诉 Git ，在合并时一定是按 “非快速合并” 进行合并。")]),t._v(" "),s("h3",{attrs:{id:"快速合并"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#快速合并"}},[t._v("#")]),t._v(" 快速合并")]),t._v(" "),s("p",[t._v("我们以将 feature 分支合并进 master 分支为例，如果 master 分支相比 feature 分支而言，没有额外的提交，这种情况下 Git 的合并行为就是快速合并。")]),t._v(" "),s("p",[t._v("先观察下面的这种情况：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://hemiao3000.gitee.io/java-note-img/images/git/img/git-merge-ff-0.png",alt:"git-merge-1"}})]),t._v(" "),s("p",[t._v("在上图中，feature 分支上的内容比 master 分支的内容只多不少，即 feature 分支完全 “涵盖” 了 master 分支的内容。")]),t._v(" "),s("div",{staticClass:"custom-block warning"},[s("p",{staticClass:"custom-block-title"},[t._v("注意")]),t._v(" "),s("p",[t._v("通常 feature 分支的 C3 和 master 分支的 C2 之间的 “连线” 歪着画效果会更显著一些，只不过 GitKraken 将它们画成了一条直线。")])]),t._v(" "),s("p",[t._v("这种情况下，执行 git merge --ff 过程效果如下：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://hemiao3000.gitee.io/java-note-img/images/git/img/git-merge-ff.gif",alt:"git-merge-ff"}})]),t._v(" "),s("p",[s("img",{attrs:{src:"https://hemiao3000.gitee.io/java-note-img/images/git/img/git-top-10-01.gif",alt:"git-top-10-01"}})]),t._v(" "),s("p",[t._v("对比一下，在同样的情况下，执行 git merge --no-ff 的效果：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://hemiao3000.gitee.io/java-note-img/images/git/img/git-merge-no-ff.gif",alt:"git-merge-no-ff"}})]),t._v(" "),s("p",[s("img",{attrs:{src:"https://hemiao3000.gitee.io/java-note-img/images/git/img/git-top-10-02.gif",alt:"git-top-10-02"}})]),t._v(" "),s("p",[t._v("“快速合并” 和 “非快速合并” 的最大区别在于：普通合并/非快速合并，会产生一个新的提交节点，稍微思索一下，你就会发现，而这个新的提交节点实际上并没有必要存在，因为它（C4）和 feature 分支的 C3 的内容是一样的！")]),t._v(" "),s("h3",{attrs:{id:"使用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用场景"}},[t._v("#")]),t._v(" 使用场景")]),t._v(" "),s("p",[t._v("先说结论：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("非快速提交（ "),s("code",[t._v("--no-ff")]),t._v(" ）具有普适性，无论什么情况都能用，而快速提交（ "),s("code",[t._v("--ff")]),t._v(" ）只在某些情况下能用；")])]),t._v(" "),s("li",[s("p",[t._v("在既可以使用 "),s("code",[t._v("--ff")]),t._v(" ，又可以使用 "),s("code",[t._v("--no-ff")]),t._v(" 的时候，使用 "),s("code",[t._v("--ff")]),t._v(" 之后的提交记录更合理一些。即，不用生成一个没有必要的新 “结点” 。")])])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://hemiao3000.gitee.io/java-note-img/images/git/img/git-merge-2.png",alt:"git-merge-2"}})]),t._v(" "),s("p",[t._v("上图中，左图只能使用 --no-ff 方式合并，而右图则在 --no-ff 之外，还可以使用 --ff 方式合并。左右两图的差异在于："),s("strong",[t._v("feature 分支是否是基于 master 分支的末端"),s("small",[t._v("（即，master 最新节点）")]),t._v("？")])]),t._v(" "),s("p",[t._v("如果是，那么就可以使用 --ff 方式合并"),s("small",[t._v("（以减少生成一个逻辑上不必要的节点）")]),t._v("。如下图：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://hemiao3000.gitee.io/java-note-img/images/git/img/git-merge-ff.gif",alt:"git-merge-ff"}})]),t._v(" "),s("p",[t._v("否则，就只能以 --no-ff 方式合并：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://hemiao3000.gitee.io/java-note-img/images/git/img/git-merge-no-ff.gif",alt:"git-merge-no-ff"}})]),t._v(" "),s("h3",{attrs:{id:"git-merge-默认行为"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#git-merge-默认行为"}},[t._v("#")]),t._v(" git merge 默认行为")]),t._v(" "),s("p",[t._v("在你使用 git merge 命令没有指定合并方式时，Git 总是先判断当前是否能进行快速合并，如果不行，它再执行非快速合并。")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("快速合并只适用于部分合并情况，而非快速合并适用于所有的合并情况；")])]),t._v(" "),s("li",[s("p",[t._v("快速合并会让历史记录中 “省” 一个合并节点。")])])])])}),[],!1,null,null,null);a.default=v.exports}}]);