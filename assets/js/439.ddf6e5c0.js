(window.webpackJsonp=window.webpackJsonp||[]).push([[439],{907:function(a,s,t){"use strict";t.r(s);var n=t(62),e=Object(n.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"感知-aware-spring-框架的能力"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#感知-aware-spring-框架的能力"}},[a._v("#")]),a._v(" 感知（Aware）Spring 框架的能力")]),a._v(" "),t("p",[a._v("我们在谈到 Spring 解耦能力的时候，大部分其实是在讲 Spring 的 IOC 实现控制反转和依赖注入。但在 Spring 的思想中，"),t("strong",[a._v("解耦并不只是业务代码间的解耦，还包括业务代码与框架间的解耦")]),a._v("，Spring 想要做到业务代码对框架的无感知。所以 Spring 有意识的隔离了框架代码和业务代码，正常情况下，我们在业务代码中是无法感知和使用 Spring 框架的一些方法的。")]),a._v(" "),t("p",[a._v("这也带来了一个问题，那就是如果我们真的需要使用 Spring 一些方法，比如获得上下文，比如获得 Bean 容器，这时应该怎么办呢？Spring 提供了一种感知 Spring 框架功能的能力，那就是 Aware 接口。使用 Aware 接口，我们基本可以获得 Spring 所有的核心对象，代价是业务代码和 Spring 框架强耦合。")]),a._v(" "),t("p",[t("strong",[a._v("Aware 接口解决的核心问题是如何在业务代码中获得 Spring 框架内部对象的问题。")])]),a._v(" "),t("p",[a._v("Aware 接口用做标记使用，实现该接口就表明需要使用 Spring 框架中的一些对象。")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("interface")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Aware")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),t("p",[a._v("Spring 并不会一股脑的将所有的对象都给到实现了 Aware 接口的类，这也不符合迪米特法则。所以 Aware 接口有很多的子接口，这些子接口表明需要使用的 Spring 资源。比如 BeanNameAware，表明需要知道该类的实例在 Spring 容器中的名称，这个接口中的 setBeanName 方法将由 Spring 调用，将 bean 名称传递给实现了该接口的类。")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("interface")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("BeanNameAware")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("extends")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Aware")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("setBeanName")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" name"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),t("p",[a._v("如下是使用示例，可以看出，对象获得了 bean 的名称，并将其存储为成员变量。")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@Component")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("AwareDemo")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("implements")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("BeanNameAware")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" beanName"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n    "),t("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@Override")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("setBeanName")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" name"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("beanName "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" name"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),t("p",[a._v("除了 BeanNameAware 外，Spring 还内置了很多 Aware 接口的子接口。比如")]),a._v(" "),t("ul",[t("li",[a._v("BeanFactoryAware，顾名思义，获取 Spring 容器 beanFactory；ApplicationContextAware，获取当前的applicationContext；")]),a._v(" "),t("li",[a._v("ApplicationEventPulisherAware，获取应用事件发布器，可以用来发布事件；EnvironmentAware，获取环境相关信息，如属性、配置信息等。")])]),a._v(" "),t("p",[a._v("Aware 接口家族很大，使用的方式也相同，就不一一列举了。")]),a._v(" "),t("p",[a._v("Spring 是在什么时候执行 Aware 接口的 setXXX 方法，将框架对象传入的呢？")]),a._v(" "),t("p",[a._v("这里分 2 种情况：")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("BeanNameAware、BeanClassLoaderAware、BeanFactoryAware 这 3 个接口的实现类的 bean 在被 Spring 框架初始化时，被 Spring 框架调用了它们的 setXxx 方法，传入了所需的对象；")])]),a._v(" "),t("li",[t("p",[a._v("其它的 Aware 接口的子接口都是通过 Spring 容器的 BeanPostProcessor（后置处理器）在 bean 的创建和初始化之后，被传入的所需的对象。")])])]),a._v(" "),t("h2",{attrs:{id:"spring-自带的线程池-threadpooltaskexecutor"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-自带的线程池-threadpooltaskexecutor"}},[a._v("#")]),a._v(" Spring 自带的线程池 ThreadPoolTaskExecutor")]),a._v(" "),t("p",[a._v("Spring 默认也是自带了一个线程池方便我们开发，它就是 ThreadPoolTaskExecutor 。")])])}),[],!1,null,null,null);s.default=e.exports}}]);