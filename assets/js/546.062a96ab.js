(window.webpackJsonp=window.webpackJsonp||[]).push([[546],{1016:function(t,o,n){"use strict";n.r(o);var a=n(62),e=Object(a.a)({},(function(){var t=this,o=t.$createElement,n=t._self._c||o;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"action-和-action-辅助函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#action-和-action-辅助函数"}},[t._v("#")]),t._v(" Action 和 Action 辅助函数")]),t._v(" "),n("p",[t._v("用 Mutation 只能做到同步变更，而 Action 用于实现异步变更。")]),t._v(" "),n("p",[t._v("关于 “vuex中为什么把把异步操作封装在action，把同步操作放在mutations？” 的问题，vue 的作者尤雨溪在知乎上有专门的回答：\n​")]),t._v(" "),n("blockquote",[n("p",[t._v("中文翻译可能有些偏差（不是我翻的）。区分 actions 和 mutations 并不是为了解决竞态问题，而是为了能用 devtools 追踪状态变化。")]),t._v(" "),n("p",[t._v("事实上在 vuex 里面 actions 只是一个架构性的概念，并不是必须的，说到底只是一个函数，你在里面想干嘛都可以，只要最后触发 mutation 就行。异步竞态怎么处理那是用户自己的事情。vuex 真正限制你的只有 mutation 必须是同步的这一点（在 redux 里面就好像 reducer 必须同步返回下一个状态一样）。")]),t._v(" "),n("p",[t._v("同步的意义在于这样每一个 mutation 执行完成后都可以对应到一个新的状态（和 reducer 一样），这样 devtools 就可以打个 snapshot 存下来，然后就可以随便 time-travel 了。")]),t._v(" "),n("p",[t._v("如果你开着 devtool 调用一个异步的 action，你可以清楚地看到它所调用的 mutation 是何时被记录下来的，并且可以立刻查看它们对应的状态。其实我有个点子一直没时间做，那就是把记录下来的 mutations 做成类似 rx-marble 那样的时间线图，对于理解应用的异步状态变化很有帮助。")])]),t._v(" "),n("p",[t._v("简单来说，你要执行的操作是同步操作，那么你可以直接调用 Mutation 去修改 State 的状态；如果你要执行的操作是异步操作，那么你就需要在 Action 中执行这个异步操作，然后在异步操作的回调中，调用 Mutation 去修改 State 的状态。")])])}),[],!1,null,null,null);o.default=e.exports}}]);