(window.webpackJsonp=window.webpackJsonp||[]).push([[281],{751:function(t,l,a){"use strict";a.r(l);var s=a(62),e=Object(s.a)({},(function(){var t=this,l=t.$createElement,a=t._self._c||l;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"同时启用配置文件和注解两种配置方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#同时启用配置文件和注解两种配置方式"}},[t._v("#")]),t._v(" 同时启用配置文件和注解两种配置方式")]),t._v(" "),a("p",[t._v("虽然通过 mapper.xml 配置文件和注解都可以拿到 mapper 对象，进而操作数据库，不过，有意思地是，Mybatis 居然不排斥你同时使用 mapper.xml 和注解。")]),t._v(" "),a("p",[t._v("虽然这个特性看起来有些多余，但是实际上它极具价值，因为，注解配置虽然万般皆好，唯独有一个功能它实现不了，在这个功能上注解是取代不了 mapper.xml 配置文件的（不知道这个问题在 MyBatis 的未来的发展中会不会解决掉）。所以，MyBatis 允许两种配置方式同时使用，我们就可以同时 “享受” 注解和配置文件的全部优点的同时，又避免各自的缺点。")]),t._v(" "),a("p",[t._v("同时使用两种配置方式本质上是让 mapper.xml 和注解两者进行分工，你要做的操作和工作分配如下：")]),t._v(" "),a("ol",[a("li",[t._v("“退回” 到早期 mapper.xml 的使用方式：在核心配置文件中指定 mapper.xml 配置文件的路径名"),a("small",[t._v("（而不是指定接口所在）")]),t._v("；")]),t._v(" "),a("li",[t._v("在 mapper.xml 配置文件中配置 "),a("strong",[t._v("<resultMap>")]),t._v(" 指定映射规则，不指定 SQL 语句。SQL 语句在接口中通过 @Select 等注解指定；")]),t._v(" "),a("li",[t._v("在注解中使用 "),a("strong",[t._v("@ResultMap")]),t._v(" 注解 “引用” mapper.xml 配置文件中的映射规则。")])]),t._v(" "),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"custom-block-title"},[t._v("注意")]),t._v(" "),a("p",[t._v("映射文件中的映射规则 <resultMap> 可以有多个，他们之间通过 id 来进行区分。")])]),t._v(" "),a("p",[t._v("另外，注解是哪一点功能实现不了，反而不如 mapper.xml 配置文件，我们在复杂映射关系之后讲解。"),a("small",[t._v("其实就是 "),a("strong",[t._v("@Results")]),t._v(" 注解没有 100% 实现 <resultMap> 的全部功能。")])])])}),[],!1,null,null,null);l.default=e.exports}}]);