(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{491:function(v,_,t){"use strict";t.r(_);var p=t(62),a=Object(p.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"链表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[v._v("#")]),v._v(" 链表")]),v._v(" "),t("p",[v._v("相比数组，链表是一种稍微复杂一点的数据结构。对于初学者来说，掌握起来也要比数组稍难一些。")]),v._v(" "),t("p",[v._v("数组和链表是非常基础、非常常用的两种数据结构，会常常被放到一起比较。所以我们先来看，这两者有什么区别：")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("数组需要一块连续的内存空间来存储，对内存的要求比较高。如果我们申请一个 100MB 大小的数组，当内存中没有连续的、足够大的存储空间时，即便内存的剩余总可用空间大于 100MB，仍然会申请失败。")])]),v._v(" "),t("li",[t("p",[v._v("而链表恰恰相反，它并不需要一块连续的内存空间，它通过『指针』将一组零散的内存块串联起来使用，所以如果我们申请的是 100MB 大小的链表，根本不会有问题。")])])]),v._v(" "),t("p",[v._v("[list-01.png]")]),v._v(" "),t("p",[v._v("链表结构五花八门，最常见的链表结构有三种，它们分别是：单链表、双向链表和循环链表。")]),v._v(" "),t("h2",{attrs:{id:"单链表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单链表"}},[v._v("#")]),v._v(" 单链表")]),v._v(" "),t("p",[v._v("前面说过，链表通过指针将一组零散的内存块串联在一起。其中，内存块被称为链表的『"),t("strong",[v._v("结点")]),v._v("』。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。如图所示，这个记录下个结点地址的指针被叫作后继指针 next 。")]),v._v(" "),t("p",[v._v("[list-02.png]")]),v._v(" "),t("p",[v._v("如上图所示，在单链表中有两个结点是比较特殊的，它们分别是第一个结点和最后一个结点。我们习惯性地把第一个结点叫作『头结点』，把最后一个结点叫作『尾结点』。其中：")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("头结点用来记录链表的基地址。有了它，我们就可以遍历得到整条链表。")])]),v._v(" "),t("li",[t("p",[v._v("尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个空地址 NULL ，表示这是链表上最后一个结点。")])])]),v._v(" "),t("p",[v._v("与数组一样，链表也支持数据的查找、插入和删除操作。")]),v._v(" "),t("p",[v._v("我们知道，在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是 O(n) 。而在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以，在链表中插入和删除一个数据是非常快速的。")]),v._v(" "),t("p",[v._v("从下图中可以看出，针对链表的插入和删除操作，只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 O(1) 。")]),v._v(" "),t("p",[v._v("[list-03.png]")]),v._v(" "),t("p",[v._v("但是，有利就有弊。链表要想随机访问第 k 个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。")]),v._v(" "),t("p",[v._v("你可以把链表想象成一个队伍，队伍中的每个人都只知道自己后面的人是谁，所以当我们希望知道排在第 k 位的人是谁的时候，我们就需要从第一个人开始，一个一个地往下数。所以，链表随机访问的性能没有数组好，需要 O(n) 的时间复杂度。")]),v._v(" "),t("h2",{attrs:{id:"循环链表和双向链表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#循环链表和双向链表"}},[v._v("#")]),v._v(" 循环链表和双向链表")]),v._v(" "),t("p",[v._v("循环链表是一种特殊的单链表。实际上，循环链表也很简单。它跟单链表唯一的区别就在尾结点。我们知道，单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点。从我画的循环链表图中，你应该可以看出来，它像一个环一样首尾相连，所以叫作“循环”链表。")]),v._v(" "),t("p",[v._v("[list-04.png]")]),v._v(" "),t("p",[v._v("和单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的约瑟夫问题。尽管用单链表也可以实现，但是用循环链表实现的话，代码就会简洁很多。")]),v._v(" "),t("p",[v._v("单向链表只有一个方向，结点只有一个后继指针 next 指向后面的结点。而双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。")]),v._v(" "),t("p",[v._v("[list-05.png]")]),v._v(" "),t("p",[v._v("从图中可以看出来，双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。")]),v._v(" "),t("p",[v._v("从结构上来看，双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。")]),v._v(" "),t("p",[v._v("单链表的插入、删除操作的时间复杂度已经是 O(1) 了，双向链表的价值体现在哪？")]),v._v(" "),t("p",[v._v("以删除操作为例，从链表中删除一个数据无外乎这两种情况：")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("删除结点中“值等于某个给定值”的结点；")])]),v._v(" "),t("li",[t("p",[v._v("删除给定指针指向的结点。")])])]),v._v(" "),t("p",[v._v("尽管单纯的删除操作时间复杂度是 O(1) ，但遍历查找的时间是主要的耗时点，对应的时间复杂度为 O(n) 。根据时间复杂度分析中的加法法则，删除值等于给定值的结点对应的链表操作的总时间复杂度为 O(n)。")]),v._v(" "),t("p",[v._v("在删除节点时，由于需要去『重置』被删除节点的前一个节点的 next 指针，因此，为了找到前驱节点，如果是单向链表，，我们还是要从头结点开始遍历链表，直到 "),t("code",[v._v("p->next=q")]),v._v(" ，说明 p 是 q 的前驱结点。")]),v._v(" "),t("p",[v._v("对于双向链表来说，这种情况就比较有优势了。因为双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。")]),v._v(" "),t("p",[v._v("同理，如果我们希望在链表的某个指定结点前面插入一个结点，双向链表比单链表有很大的优势。双向链表可以在 O(1) 时间复杂度搞定，而单向链表需要 O(n) 的时间复杂度。")]),v._v(" "),t("p",[v._v("除了插入、删除操作有优势之外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。")]),v._v(" "),t("h2",{attrs:{id:"双向循环链表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#双向循环链表"}},[v._v("#")]),v._v(" 双向循环链表")]),v._v(" "),t("p",[v._v("[list-06.png]")]),v._v(" "),t("h2",{attrs:{id:"链表-vs-数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#链表-vs-数组"}},[v._v("#")]),v._v(" 链表 VS 数组")]),v._v(" "),t("p",[v._v("数组和链表是两种截然不同的内存组织方式。正是因为内存存储的区别，它们插入、删除、随机访问操作的时间复杂度正好相反。")]),v._v(" "),t("p",[v._v("[list-07.png]")]),v._v(" "),t("p",[v._v("不过，数组和链表的对比，并不能局限于时间复杂度。")]),v._v(" "),t("p",[v._v("数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。")]),v._v(" "),t("p",[v._v("数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。")]),v._v(" "),t("p",[v._v("类似于 Java 中的 ArrayList 容器所实现的动态扩容本质上是在数组中没有空闲空间时，申请一个更大的空间，将数据拷贝过去，而数据拷贝的操作是非常耗时的。")]),v._v(" "),t("p",[v._v("除此之外，如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，就有可能会导致频繁的 GC"),t("small",[v._v("（Garbage Collection，垃圾回收）")]),v._v("。")])])}),[],!1,null,null,null);_.default=a.exports}}]);