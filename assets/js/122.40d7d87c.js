(window.webpackJsonp=window.webpackJsonp||[]).push([[122],{594:function(t,e,a){"use strict";a.r(e);var r=a(62),_=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"动画图解-git-的-10-大命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#动画图解-git-的-10-大命令"}},[t._v("#")]),t._v(" 动画图解 Git 的 10 大命令")]),t._v(" "),a("h2",{attrs:{id:"_1-前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-前言"}},[t._v("#")]),t._v(" 1. 前言")]),t._v(" "),a("p",[t._v("尽管 Git 是一款非常强大的工具。")]),t._v(" "),a("p",[t._v("我发现在使用 Git 时，在头脑里可视化地想象它会非常有用：当我执行一个特定命令时，这些分支会如何交互，又会怎样影响历史记录？为什么当我在 "),a("code",[t._v("master")]),t._v(" 上执行硬重启，"),a("code",[t._v("force push")]),t._v(" 到原分支以及 "),a("code",[t._v("rimraf")]),t._v(" 我们的 "),a("code",[t._v(".git")]),t._v(" 文件夹时，我的同事哭了？我觉得创建一些最常用且最有用的 Git 命令的可视化示例会是一个完美的用例！下面我将介绍的很多命令都有可选参数——你可以使用这些参数来改变对应命令的行为。而我的示例只会涵盖命令的默认行为，而不会添加（或添加太多）可选配置！")]),t._v(" "),a("h2",{attrs:{id:"_2-合并中-merging"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-合并中-merging"}},[t._v("#")]),t._v(" 2. 合并中 Merging")]),t._v(" "),a("h2",{attrs:{id:"_3-合并冲突-merge-conflicts"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-合并冲突-merge-conflicts"}},[t._v("#")]),t._v(" 3. 合并冲突 Merge Conflicts")]),t._v(" "),a("h2",{attrs:{id:"_4-变基-rebasing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-变基-rebasing"}},[t._v("#")]),t._v(" 4. 变基（Rebasing）")]),t._v(" "),a("h2",{attrs:{id:"_5-交互式变基-interactive-rebase"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-交互式变基-interactive-rebase"}},[t._v("#")]),t._v(" 5. 交互式变基（Interactive Rebase）")]),t._v(" "),a("h2",{attrs:{id:"_6-重置-resetting"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-重置-resetting"}},[t._v("#")]),t._v(" 6. 重置（Resetting）")]),t._v(" "),a("h2",{attrs:{id:"_7-还原-reverting"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-还原-reverting"}},[t._v("#")]),t._v(" 7. 还原（Reverting）")]),t._v(" "),a("p",[t._v("另一种撤销修改的方法是执行 "),a("code",[t._v("git revert")]),t._v(" 。通过对特定的提交执行还原操作，我们会创建一个包含已还原修改的新提交。")]),t._v(" "),a("blockquote",[a("p",[t._v("git revert  执行的重置操作，也被称为「硬重置」。")])]),t._v(" "),a("p",[t._v("假设 "),a("code",[t._v("ec5be")]),t._v(" 添加了一个 "),a("code",[t._v("index.js")]),t._v(" 文件。但之后我们发现其实我们再也不需要由这个提交引入的修改了。那就还原 ec5be 提交吧！")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://hemiao3000.gitee.io/java-note-img/images/git/img/git-top-10-08.gif",alt:"git-top-10-08"}})]),t._v(" "),a("p",[t._v("完美！提交 "),a("code",[t._v("9e78i")]),t._v(" 还原了由提交 "),a("code",[t._v("ec5be")]),t._v(" 引入的修改。在撤销特定的提交时，"),a("code",[t._v("git revert")]),t._v(" 非常有用，同时也不会修改分支的历史。")]),t._v(" "),a("h2",{attrs:{id:"_9-取回-fetching"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-取回-fetching"}},[t._v("#")]),t._v(" 9. 取回（Fetching）")]),t._v(" "),a("h2",{attrs:{id:"_10-reflog"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-reflog"}},[t._v("#")]),t._v(" 10. Reflog")]),t._v(" "),a("p",[t._v("每个人都会犯错，但犯错其实没啥！有时候你可能感觉你把 git repo 完全搞坏了，让你想完全删了了事。")]),t._v(" "),a("p",[t._v("git reflog 是一个非常有用的命令，可以展示已经执行过的所有动作的日志。包括合并、重置、还原，基本上包含你对你的分支所做的任何修改。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://hemiao3000.gitee.io/java-note-img/images/git/img/git-top-10-12.gif",alt:"git-top-10-12"}})]),t._v(" "),a("p",[t._v("如果你犯了错，你可以根据 "),a("code",[t._v("reflog")]),t._v(" 提供的信息通过重置 HEAD 来轻松地重做！")]),t._v(" "),a("p",[t._v("假设我们实际上并不需要合并原有分支。当我们执行 "),a("code",[t._v("git reflog")]),t._v(" 命令时，我们可以看到这个 repo 的状态在合并前位于 "),a("code",[t._v("HEAD@{1}")]),t._v("。那我们就执行一次 "),a("code",[t._v("git reset")]),t._v("，将 HEAD 重新指向在 "),a("code",[t._v("HEAD@{1}")]),t._v(" 的位置。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://hemiao3000.gitee.io/java-note-img/images/git/img/git-top-10-13.gif",alt:"git-top-10-13"}})]),t._v(" "),a("p",[t._v("我们可以看到最新的动作已被推送给 reflog 。")])])}),[],!1,null,null,null);e.default=_.exports}}]);