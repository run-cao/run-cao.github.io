(window.webpackJsonp=window.webpackJsonp||[]).push([[155],{623:function(e,l,t){"use strict";t.r(l);var v=t(62),_=Object(v.a)({},(function(){var e=this,l=e.$createElement,t=e._self._c||l;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"线程池"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程池"}},[e._v("#")]),e._v(" 线程池")]),e._v(" "),t("p",[e._v("线程池"),t("small",[e._v("（Thread Pool）")]),e._v("：把一个或多个线程通过统一的方式进行调度和重复使用的技术，避免了因为线程过多而带来使用上的开销。")]),e._v(" "),t("p",[e._v("为什么要使用线程池？")]),e._v(" "),t("ul",[t("li",[e._v("可重复使用已有线程，避免对象创建、消亡和过度切换的性能开销。")]),e._v(" "),t("li",[e._v("避免创建大量同类线程所导致的资源过度竞争和内存溢出的问题。")]),e._v(" "),t("li",[e._v("支持更多功能。比如，延迟任务线程池"),t("small",[e._v("（newScheduledThreadPool）")]),e._v("和缓存线程池"),t("small",[e._v("（newCachedThreadPool）")]),e._v("等。")])]),e._v(" "),t("p",[e._v("创建线程池有两种方式："),t("strong",[e._v("ThreadPoolExecutor")]),e._v(" 和 Executors"),t("small",[e._v("（后续讲解）")]),e._v(" 。")])])}),[],!1,null,null,null);l.default=_.exports}}]);