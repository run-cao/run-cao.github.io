(window.webpackJsonp=window.webpackJsonp||[]).push([[153],{625:function(a,t,s){"use strict";s.r(t);var n=s(62),v=Object(n.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"线程的调用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#线程的调用"}},[a._v("#")]),a._v(" 线程的调用")]),a._v(" "),s("h2",{attrs:{id:"_1-线程的优先级-了解、自学"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-线程的优先级-了解、自学"}},[a._v("#")]),a._v(" 1. 线程的优先级（了解、自学）")]),a._v(" "),s("p",[a._v("当一个时刻有多个线程处于可运行状态，它们需要排队等待 CPU 资源，每个线程会自动获得一个线程的优先级"),s("small",[a._v("（Priority）")]),a._v("，优先级的高低反映线程的重要或紧急程序。")]),a._v(" "),s("p",[a._v("可运行状态"),s("small",[a._v("（Runnable）")]),a._v("的线程按优先级排队，线程调度依据建立在优先级基础上的『先到先服务』原则。")]),a._v(" "),s("div",{staticClass:"custom-block warning"},[s("p",{staticClass:"custom-block-title"},[a._v("注意")]),a._v(" "),s("p",[a._v("线程的调度是操作系统的重要功能和职责。")]),a._v(" "),s("p",[a._v("线程调度的规则依赖于操作系统内核的实现。有的操作系统会充分遵守优先级规则，有的系统只是将优先级当做『"),s("strong",[a._v("建议值")]),a._v("』，而有的操作系统则完全没有优先级概念、无视优先级，完全随机。")]),a._v(" "),s("p",[s("strong",[a._v("所以不能以优先级作为控制线程先后执行顺序的手段！")])])]),a._v(" "),s("p",[a._v("线程的优先级用 1 ... 10 表示，10 表示优先级最高，默认值是 5。Thread 类中有对应的静态常量：NORM_PRIORITY、MIN_PRIORITY、MAX_PRIORITY 。")]),a._v(" "),s("p",[a._v("线程的优先级可以通过 "),s("strong",[a._v("Thread#setPriority(int level)")]),a._v(" 方法更改。")]),a._v(" "),s("h2",{attrs:{id:"_2-实现线程调度的方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-实现线程调度的方法"}},[a._v("#")]),a._v(" 2. 实现线程调度的方法")]),a._v(" "),s("p",[a._v("线程调度的实现核心思路只有一个："),s("strong",[a._v("通过各种手段，迫使一个线程"),s("small",[a._v("（通常是当前执行线程）")]),a._v("让出 CPU ，从而让其它线程拥有执行机会")]),a._v("。")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("手段一："),s("strong",[a._v("Thread#join")]),a._v(" 方法")]),a._v(" "),s("p",[a._v("Thread#join 方法会导致当前线程阻塞"),s("small",[a._v("（让出 CPU）")]),a._v("，等待调用该方法的线程"),s("small",[a._v("（即，Thread 对象所代表的那个线程）")]),a._v("结束后再继续执行本线程。")])]),a._v(" "),s("li",[s("p",[a._v("手段二："),s("strong",[a._v("Thread.sleep")]),a._v(" 方法")]),a._v(" "),s("p",[a._v("Thread.sleep 方法会导致当前线程睡眠"),s("small",[a._v("（本质上也是阻塞，迫使当前线程让出 CPU）")]),a._v("，在指定时间到期后，重新进入可运行状态。")])]),a._v(" "),s("li",[s("p",[a._v("手段三："),s("strong",[a._v("Thread.yield")]),a._v(" 方法")]),a._v(" "),s("p",[a._v("Thread.yield 方法稍微有点不同，它让当前线程让出 CPU ，但并不是进入阻塞状态，而是直接进入 Runnable 状态。")])])]),a._v(" "),s("p",[a._v("需要注意的是，当前线程让出 CPU 之后，接下来是哪个线程执行"),s("small",[a._v("（从 Runnable 状态变为 Running 状态）")]),a._v("带有『"),s("strong",[a._v("不确定性")]),a._v("』。")]),a._v(" "),s("h2",{attrs:{id:"_3-线程的同步与互斥"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-线程的同步与互斥"}},[a._v("#")]),a._v(" 3. 线程的同步与互斥")]),a._v(" "),s("p",[a._v("当两个或多个线程需要访问同一资源"),s("small",[a._v("（或执行同一段代码时）")]),a._v("，需要某一时刻只能被一个线程使用的方式，称为线程『"),s("strong",[a._v("互斥")]),a._v("』。")]),a._v(" "),s("p",[a._v("当两个或多个线程以互斥的方式访问完同一资源"),s("small",[a._v("（或执行同一段代码）")]),a._v("后，『通知』其他线程的方式，称为线程『"),s("strong",[a._v("同步")]),a._v("』。")]),a._v(" "),s("blockquote",[s("p",[a._v("同步与互斥通常总是一起出现的。只出现互斥，不出现同步，意味着代码逻辑是一种极简单的多线程状况。")])]),a._v(" "),s("h2",{attrs:{id:"_4-synchronized-关键字"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-synchronized-关键字"}},[a._v("#")]),a._v(" 4. synchronized 关键字")]),a._v(" "),s("p",[a._v("使用 "),s("strong",[a._v("synchronized")]),a._v(" 关键字修饰的方法控制对类成员变量的访问。每个类实例都对应一把锁，方法一旦执行，就独占该锁，直到方法结束时才将锁释放；此后其它被阻塞的线程才能获得该锁，重新进入可执行状态。")]),a._v(" "),s("p",[a._v("这种机制保证了同一时刻，对于每一个实例，其所声明为 synchronized 的方法只能有一个处于可执行状态，从而有效地避免了类成员变量的访问冲突。")]),a._v(" "),s("p",[a._v("语法：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[a._v("访问修饰符 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("synchronized")]),a._v(" 返回类型 方法名 "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v(" \n")])])]),s("p",[a._v("或")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("synchronized")]),a._v(" 访问修饰符 返回类型 方法名 "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v(" \n")])])]),s("p",[a._v("synchronized 方法的缺陷在于：如果将一个耗时的方法声明为 synchronized 将会使其它线程阻塞时间过长，从而影响系统执行效率和用户体验。")]),a._v(" "),s("p",[a._v("同步代码块是同步方法的缺陷的解决方案，它『锁住』的不是整个方法，而是方法中的一个代码片段。")]),a._v(" "),s("p",[a._v("语法：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("synchronized")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("一个对象"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("p",[a._v("这里的『一个对象』通常是一个字符串常量对象。")])])}),[],!1,null,null,null);t.default=v.exports}}]);