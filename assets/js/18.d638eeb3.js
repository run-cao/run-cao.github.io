(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{490:function(a,t,_){"use strict";_.r(t);var v=_(62),s=Object(v.a)({},(function(){var a=this,t=a.$createElement,_=a._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h1",{attrs:{id:"数组"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[a._v("#")]),a._v(" 数组")]),a._v(" "),_("p",[a._v("数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。")]),a._v(" "),_("p",[a._v("这个定义里有几个关键词，理解了这几个关键词，你就能彻底掌握数组的概念了。")]),a._v(" "),_("h3",{attrs:{id:"线性表-linear-list"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#线性表-linear-list"}},[a._v("#")]),a._v(" 线性表"),_("small",[a._v("（Linear List）")])]),a._v(" "),_("p",[a._v("顾名思义，线性表就是数据排成像一条线一样的结构。每个线性\n表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。")]),a._v(" "),_("p",[a._v("[array-01.png]")]),a._v(" "),_("p",[a._v("而与它相对立的概念是非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。")]),a._v(" "),_("p",[a._v("[array-02.png]")]),a._v(" "),_("h3",{attrs:{id:"连续的内存空间和相同类型的数据"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#连续的内存空间和相同类型的数据"}},[a._v("#")]),a._v(" 连续的内存空间和相同类型的数据")]),a._v(" "),_("p",[a._v("正是因为这两个限制，它才有了一个堪称“杀手\n锏”的特性：“随机访问”。但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比\n如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。")]),a._v(" "),_("p",[a._v("道数组是如何实现根据下标随机访问数组元素的？")]),a._v(" "),_("p",[a._v("我们一个长度为 10 的 int 类型的数组 "),_("code",[a._v("int[] a = new int[10]")]),a._v(" 来举例。在下面的图中，计算机给数组 "),_("code",[a._v("a[10]")]),a._v(" ，分配了一块连续内存空间 1000～1039 ，其中，内存块的首地址为 "),_("code",[a._v("base_address = 1000")]),a._v(" 。")]),a._v(" "),_("p",[a._v("[array-03.png]")]),a._v(" "),_("p",[a._v("我们知道，计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：")]),a._v(" "),_("div",{staticClass:"language-java extra-class"},[_("pre",{pre:!0,attrs:{class:"language-java"}},[_("code",[a._v("a"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("i"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("_address "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" base_address "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" i "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" data_type_size\n")])])]),_("p",[a._v("其中 data_type_size 表示数组中每个元素的大小。上面的例子中，数组中存储的是 int 类型数据，所以 data_type_size 就为 4 个字节。")]),a._v(" "),_("div",{staticClass:"custom-block warning"},[_("p",{staticClass:"custom-block-title"},[a._v("注意")]),a._v(" "),_("p",[a._v("这里我们要特别纠正一个“错误”。在面试的时候，常常会被问数组和链表的区别。很多人都回答说，“链表适合插入、删除，时间复杂度 O(1)；数组适合查找，查找时间复杂度为 O(1)”。")]),a._v(" "),_("p",[a._v("实际上，这种表述是不准确的。数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)。")]),a._v(" "),_("p",[a._v("所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。")])]),a._v(" "),_("h2",{attrs:{id:"低效的-插入-和-删除"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#低效的-插入-和-删除"}},[a._v("#")]),a._v(" 低效的“插入”和“删除”")]),a._v(" "),_("p",[a._v("暂缺")]),a._v(" "),_("h2",{attrs:{id:"警惕数组的访问越界问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#警惕数组的访问越界问题"}},[a._v("#")]),a._v(" 警惕数组的访问越界问题")]),a._v(" "),_("p",[a._v("暂缺")]),a._v(" "),_("h2",{attrs:{id:"容器能否完全替代数组"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#容器能否完全替代数组"}},[a._v("#")]),a._v(" 容器能否完全替代数组？")]),a._v(" "),_("p",[a._v("针对数组类型，很多语言都提供了容器类，比如 Java 中的 ArrayList、C++ STL 中的 vector。"),_("small",[a._v("（以 Java 的 ArrayList 为例）")]),a._v("它们与数组相比，到底有哪些优势呢？")]),a._v(" "),_("p",[a._v("ArrayList 最大的优势就是可以『"),_("strong",[a._v("将很多数组操作的细节封装起来")]),a._v("』。比如前面提到的数组插入、删除数据时需要搬移其他数据等。另外，它还有一个优势，就是『"),_("strong",[a._v("支持动态扩容")]),a._v("』。")]),a._v(" "),_("p",[a._v("数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间。如果我们申请了大小为 10 的数组，当第 11 个数据需要存储到数组中时，我们就需要重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。")]),a._v(" "),_("p",[a._v("如果使用 ArrayList ，我们就完全不需要关心底层的扩容逻辑，ArrayList 已经帮我们实现好了。每次存储空间不够的时候，它都会将空间自动扩容为 1.5 倍大小。")]),a._v(" "),_("p",[a._v("不过，这里需要注意一点，因为扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好在创建 ArrayList 的时候事先指定数据大小。")]),a._v(" "),_("p",[a._v("那么数组的价值体现在哪里？")]),a._v(" "),_("ol",[_("li",[_("p",[a._v("Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。")])]),a._v(" "),_("li",[_("p",[a._v("如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。")])]),a._v(" "),_("li",[_("p",[a._v("（个人的喜好）当要表示多维数组时，用数组往往会更加直观。比如 "),_("code",[a._v("Object[][] array;")]),a._v(" ，而用容器的话则需要这样定义："),_("code",[a._v("ArrayList<ArrayList > array")]),a._v(" 。")])])]),a._v(" "),_("p",[a._v("总结一下：")]),a._v(" "),_("ul",[_("li",[a._v("对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。")]),a._v(" "),_("li",[a._v("但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。")])])])}),[],!1,null,null,null);t.default=s.exports}}]);