(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{515:function(s,e,a){"use strict";a.r(e);var r=a(62),v=Object(r.a)({},(function(){var s=this,e=s.$createElement,a=s._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"docker-中的网络"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#docker-中的网络"}},[s._v("#")]),s._v(" Docker 中的网络")]),s._v(" "),a("p",[s._v("Docker 中有 3 种网络模式：bridge 、host 和 none 。这 3 种不同的网络模式的背后，存在一个驱动（ Driver ）的概念。")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("bridge 是驱动"),a("small",[s._v("（ Driver ）")]),s._v("类型为 bridge 的默认网络")])]),s._v(" "),a("li",[a("p",[s._v("host 是驱动"),a("small",[s._v("（ Driver ）")]),s._v("类型为 host 的默认网络")])]),s._v(" "),a("li",[a("p",[s._v("none 是驱动"),a("small",[s._v("（ Driver ）")]),s._v("类型为 none 的默认网络")])])]),s._v(" "),a("p",[s._v("你可以通过下述命令查看 Docker当前的网络情况：")]),s._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[s._v("docker network "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("ls")]),s._v("\n")])])]),a("p",[s._v("如果愿意，你可以任意创建驱动"),a("small",[s._v("（ Driver ）")]),s._v("类型为 bridge / host / none 的网络，你所创建出来的不同驱动类型的网络，所展现的特性自然和上述的 3 个同类型驱动网络相似。")]),s._v(" "),a("p",[s._v("不过，一般情况下，我们更多的是是创建新的 bridge 网络，而不会再创建新的 host 和 none 。")]),s._v(" "),a("h2",{attrs:{id:"_1-bridge-网络"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-bridge-网络"}},[s._v("#")]),s._v(" 1. bridge 网络")]),s._v(" "),a("p",[s._v("在驱动类型是 bridge 的网络"),a("small",[s._v("（ 默认网络为 bridge ）")]),s._v("中，宿主机和虚拟机"),a("small",[s._v("（即，容器）")]),s._v("之间的地位更平等，在概念上，它们都连接到了一个叫作 “"),a("strong",[s._v("网桥")]),s._v("” 的东西上，这正是 “bridge 网络” 这个称呼的由来。")]),s._v(" "),a("p",[s._v("网桥可以不只有一个"),a("small",[s._v("（当然，默认就一个）")]),s._v("，连在同一个网桥上的宿主机和虚拟机就位于同一个虚拟网络中。")]),s._v(" "),a("p",[s._v("在这种模式下，Docker 会为每一个虚拟机"),a("small",[s._v("（即，容器）")]),s._v("分配一个虚拟 IP ，毫无疑问，连接到同一个网桥"),a("small",[s._v("（即，在同一个虚拟网络中）")]),s._v("的虚拟机"),a("small",[s._v("（即，容器）")]),s._v("的虚拟 IP 一定是在同一个网段中的。")]),s._v(" "),a("p",[s._v("你可以通过以下命令查看某个容器的 IP 地址：")]),s._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[s._v("docker inspect --format"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'{{.NetworkSettings.IPAddress}}'")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("container-name or container-id"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("\n")])])]),a("p",[s._v("需要注意的是，宿主机一定是连上了所有的网桥，在所有的虚拟网络中，都有它的 “位置” 。宿主机每 “加入” 一个网桥，它就会 “多” 出来一个虚拟 IP ，如果你的 Docker 中有多个 bridge 网络，你的宿主机的 IP 可能就会类似如下：")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("inet 127.0.0.1/8                          scope host lo\ninet 192.172.0.24/24  brd 192.172.0.255   scope global noprefixroute ens192\ninet 172.17.0.1/16    brd 172.17.255.255  scope global docker0\ninet 172.24.0.1/16    brd 172.24.255.255  scope global br-e4fe43512b86\ninet 172.28.0.1/16    brd 172.28.255.255  scope global br-9dcd68d72a74\ninet 192.168.176.1/20 brd 192.168.191.255 scope global br-7410b50c2487\ninet 192.168.192.1/20 brd 192.168.207.255 scope global br-d066f13bc64d\ninet 192.168.208.1/20 brd 192.168.223.255 scope global br-a783e7de5812\ninet 172.20.0.1/16    brd 172.20.255.255  scope global br-1a64e94053f5\ninet 192.168.224.1/20 brd 192.168.239.255 scope global br-91df31410f57\ninet 192.168.240.1/20 brd 192.168.255.255 scope global br-fe8c02484194\n")])])]),a("p",[s._v("在 Docker 中每一个网桥都有名字，每一个网桥做组织起来的虚拟子网也有名字。docker 默认的网桥叫 bridge ，由它组织起来的虚拟子网叫 docker0 。")]),s._v(" "),a("p",[s._v("你可以通过 "),a("code",[s._v("docker network ls")]),s._v(" 来查看网桥"),a("small",[s._v("（ bridge ）")]),s._v("的名字；在宿主机中，通过 "),a("code",[s._v("ip addr | grep 'inet '")]),s._v(" 来查看虚拟子网的名字。上述示例中的 "),a("code",[s._v("docker0")]),s._v(" 和 "),a("code",[s._v("br-xxx")]),s._v(" 都是宿主机所在的虚拟子网名。")]),s._v(" "),a("p",[s._v("另外，在知道了网桥"),a("small",[s._v("（ bridge ）")]),s._v(" 的名字之后，你可以通过 "),a("code",[s._v("docker network inspect <网桥名>")]),s._v(" 来查看由这个网桥所组织起来的虚拟子网中有多少台机器。例如：")]),s._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[s._v("docker network inspect redis_default\n")])])]),a("h2",{attrs:{id:"_2-link"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-link"}},[s._v("#")]),s._v(" 2. --link")]),s._v(" "),a("p",[s._v("同一个虚拟子网"),a("small",[s._v("（即，连接的是同一个网桥）")]),s._v("中的容器，可以使用 "),a("code",[s._v("--link")]),s._v(" 参数来实现容器间的通信，而不用繁琐地考虑 IP 问题。")]),s._v(" "),a("p",[s._v("例如：")]),s._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[s._v("docker run -d --name mysql-3306 -p "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("3306")]),s._v(":3306 -e "),a("span",{pre:!0,attrs:{class:"token assign-left variable"}},[s._v("MYSQL_ROOT_PASSWORD")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("123456")]),s._v(" mysql:8.0.16\ndocker run -d --name mysql-3307 -p "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("3307")]),s._v(":3306 -e "),a("span",{pre:!0,attrs:{class:"token assign-left variable"}},[s._v("MYSQL_ROOT_PASSWORD")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("123456")]),s._v(" --link mysql-3306 mysql:8.0.16\n")])])]),a("p",[s._v("由于没有额外指定，因此 "),a("code",[s._v("mysql-3306")]),s._v(" 和 "),a("code",[s._v("mysql-3307")]),s._v(" 这两个容器都是按照默认的设置，位于 docker0 子网中"),a("small",[s._v("（连接的都是 docker0 网桥）")]),s._v("。")]),s._v(" "),a("p",[s._v("在创建、启动 mysql-3307 的容器时，我们多使用了一个参数 "),a("code",[s._v("--link mysql-3306")]),s._v(" ，这个参数会让 mysql-3307 在未来的使用中，原本需要指定 mysql-3306 具体 IP 的地方，使用 "),a("code",[s._v("mysql-3306")]),s._v(" 这个容器名替代。")]),s._v(" "),a("ol",[a("li",[a("p",[s._v("我们可以先进入到 mysql-3306 容器中，使用 mysql client 在 mysql-3306 数据库中创建一个任意的表"),a("small",[s._v("（作为演示的素材）")]),s._v("。")])]),s._v(" "),a("li",[a("p",[s._v("我们再进入到 mysql-3307 容器中，使用 mysql-3307 的 mysql client 去连接 mysql-3306 的 mysql server 。本来，我们应该输入类似如下命令：")]),s._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[s._v("mysql -h mysql -h "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("172.17")]),s._v(".0.2 -u root -p123456\n")])])]),a("p",[s._v("其中 "),a("code",[s._v("-h 172.17.0.2")]),s._v(" 是在指定 mysql-3306 的 IP 地址。")]),s._v(" "),a("p",[s._v("但是，我们使用 mysql-3306 的容器名 "),a("code",[s._v("mysql-3306")]),s._v(" 来代替 mysql-3306 的 IP 地址，你会发现，依然能正常连接。")])])]),s._v(" "),a("h2",{attrs:{id:"_3-host-网络"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-host-网络"}},[s._v("#")]),s._v(" 3. host 网络")]),s._v(" "),a("p",[s._v("如果说 bridge 网络模式下，虚拟机"),a("small",[s._v("（即，容器）")]),s._v("的地位与宿主机 “平起平坐” ，那么，在 host 网络模式下，虚拟机"),a("small",[s._v(">（即，容器）")]),s._v("更像是宿主机中的一个进程，而 “不像是一个独立的机器” 。")]),s._v(" "),a("p",[s._v("在 host 模式中，虚拟机"),a("small",[s._v("（即，容器）")]),s._v(" 没有自己的 IP ，它用到的是宿主机的 IP"),a("small",[s._v("（和端口）")]),s._v("，这种情况下，各个虚拟机"),a("small",[s._v("（即，容器）")]),s._v("谁是谁，主要靠它占用的是宿主机的哪个端口来分辨。")])])}),[],!1,null,null,null);e.default=v.exports}}]);