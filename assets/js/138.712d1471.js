(window.webpackJsonp=window.webpackJsonp||[]).push([[138],{610:function(e,n,t){"use strict";t.r(n);var o=t(62),l=Object(o.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"synchronized-和-volatile"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#synchronized-和-volatile"}},[e._v("#")]),e._v(" synchronized 和 volatile")]),e._v(" "),t("p",[e._v("synchronized 是悲观锁的实现，因为 synchronized 修饰的代码，每次执行时会进行加锁操作，同时只允许一个线程进行操作，所以它是悲观锁的实现。")]),e._v(" "),t("p",[e._v("synchronized 使用的是非公平锁，并且是不可设置的。这是因为非公平锁的吞吐量大于公平锁，并且是主流操作系统线程调度的基本选择，所以这也是 synchronized 使用非公平锁原由。")]),e._v(" "),t("blockquote",[t("p",[e._v("为什么非公平锁吞吐量大于公平锁？")]),e._v(" "),t("p",[e._v("比如 A 占用锁的时候，B 请求获取锁，发现被 A 占用之后，堵塞等待被唤醒，这个时候 C 同时来获取 A 占用的锁，如果是公平锁 C 后来者发现不可用之后一定排在 B 之后等待被唤醒，而非公平锁则可以让 C 先用，在 B 被唤醒之前 C 已经使用完成，从而节省了 C 等待和唤醒之间的性能消耗，这就是非公平锁比公平锁吞吐量大的原因。")])]),e._v(" "),t("p",[e._v("volatile 是 Java 虚拟机提供的最轻量级的同步机制。当变量被定义成 volatile 之后，具备 2 种特性：")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("保证此变量对所有线程的可见性，当一条线程修改了这个变量的值，修改的新值对于其他线程是可见的（可以立即得知的）；")])]),e._v(" "),t("li",[t("p",[e._v("禁止指令重排序优化，普通变量仅仅能保证在该方法执行过程中，得到正确结果，但是不保证程序代码的执行顺序。")])])]),e._v(" "),t("p",[e._v("synchronized 既能保证可见性，又能保证原子性，而 volatile 只能保证可见性，无法保证原子性。比如，i++ 如果使用 synchronized 修饰是线程安全的，而 volatile 会有线程安全的问题。")])])}),[],!1,null,null,null);n.default=l.exports}}]);