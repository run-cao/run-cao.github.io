(window.webpackJsonp=window.webpackJsonp||[]).push([[143],{614:function(n,o,t){"use strict";t.r(o);var i=t(62),a=Object(i.a)({},(function(){var n=this,o=n.$createElement,t=n._self._c||o;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"条件-condition-等待"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#条件-condition-等待"}},[n._v("#")]),n._v(" 条件（Condition）等待")]),n._v(" "),t("p",[n._v("Java 中条件变量都实现了 java.util.concurrent.locks.Condition 接口，条件变量的实例化是通过一个 Lock 对象上调用 "),t("code",[n._v("newCondition()")]),n._v(" 方法来获取的，这样，条件就和一个锁对象绑定起来了。因此，Java 中的条件变量只能和锁配合使用，来控制并发程序访问竞争资源的安全。")]),n._v(" "),t("p",[n._v("在 Condition 中，用 "),t("strong",[n._v("await()")]),n._v(" 替换 wait()，用 "),t("strong",[n._v("signal()")]),n._v(" 替换 notify()，用 "),t("strong",[n._v("signalAll()")]),n._v(" 替换 notifyAll()，传统线程的通信方式，Condition 都可以实现。再次提醒，Condition 是被绑定到 Lock 上的，要创建一个 Lock 的 Condition 必须用 newCondition() 方法。 这样看来，Condition 和传统的线程通信没什么区别，Condition 的强大之处在于它可以为多个线程间建立不同的 Condition 。")])])}),[],!1,null,null,null);o.default=a.exports}}]);