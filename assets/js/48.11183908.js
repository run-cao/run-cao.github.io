(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{519:function(s,t,a){"use strict";a.r(t);var e=a(62),r=Object(e.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"其它"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#其它"}},[s._v("#")]),s._v(" 其它")]),s._v(" "),a("h2",{attrs:{id:"docker容器启动时初始化mysql数据库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#docker容器启动时初始化mysql数据库"}},[s._v("#")]),s._v(" Docker容器启动时初始化Mysql数据库")]),s._v(" "),a("h3",{attrs:{id:"原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[s._v("#")]),s._v(" 原理")]),s._v(" "),a("p",[s._v("当Mysql容器首次启动时，会在 /docker-entrypoint-initdb.d目录下扫描 .sh，.sql，.sql.gz类型的文件。如果这些类型的文件存在，将执行它们来初始化一个数据库。这些文件会按照字母的顺序执行。默认情况下它们会初始化在启动容器时声明的 MYSQL_DATABASE变量定义的数据库中,例如下面的命令会初始化一个REGION_DB 数据库：")]),s._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[s._v("$ docker run --name some-mysql -e "),a("span",{pre:!0,attrs:{class:"token assign-left variable"}},[s._v("MYSQL_DATABASE")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v("REGION_DB -d mysql:tag\n")])])]),a("p",[s._v("如果你的启动命令没有指定数据库那么就必须在数据库DDL脚本中声明并指定使用该数据库。否则就会实现下面的异常：")]),s._v(" "),a("div",{staticClass:"language-text extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("ERROR 1046 (3D000) at line 7: No database selected\n")])])]),a("p",[s._v("那么接下来我们将利用这一机制来实现Docker容器启动时初始化数据库。")]),s._v(" "),a("h3",{attrs:{id:"自定义dockerfile"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自定义dockerfile"}},[s._v("#")]),s._v(" 自定义Dockerfile")]),s._v(" "),a("p",[s._v("我们编写自己的Dockerfile来实现我们的需求，这里以 Mysql:5.7 为例。不同的版本可能有一定的出入，需要详细去阅读官方文档。脚本如下：")]),s._v(" "),a("div",{staticClass:"language-text extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("FROM mysql:5.7\nLABEL OG=felord.cn\nCOPY utf8mb4.cnf /etc/mysql/conf.d/utf8mb4.cnf\nCOPY ./sql  /tmp/sql\nRUN mv /tmp/sql/*.sql /docker-entrypoint-initdb.d\nRUN rm -rf /tmp/sql\n")])])]),a("ul",[a("li",[s._v("第一步，引入官方 Mysql:5.7 Docker镜像。")]),s._v(" "),a("li",[s._v("第二步，无实际意义，主要是作者、组织信息。")]),s._v(" "),a("li",[s._v("第三步，很重要！本来我没有配置第三行，结果运行容器后发现初始化数据的中文全部乱码了。所以需要在初始化数据库前修改Mysql的编码等配置，这里我顺便把时区也改为了+8:00。")]),s._v(" "),a("li",[s._v("第四步，复制包含数据库脚本的 ./sql文件夹到镜像的/tmp/sql下。")]),s._v(" "),a("li",[s._v("第五步，使用 mv 命令把第四步拷贝的文件夹下的所有.sql文件复制到 /docker-entrypoint-initdb.d下，这样才能利用2.章节的机制进行初始化数据库。")]),s._v(" "),a("li",[s._v("第六步，删除使用过的临时目录。")])]),s._v(" "),a("p",[s._v("然后你可以通过构建镜像命令构建自定义的Mysql镜像：")]),s._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 一定不要忘记最后的一个 . 点")]),s._v("\ndocker build -t mysql:5.7c "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v(".")]),s._v("\n")])])]),a("p",[s._v("通过 mysql:5.7c 镜像启动一个名称为 mysql-service 的容器，root 密码为 123456，并持久化数据到宿主机 D:/mysql/data 下：")]),s._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[s._v("docker run --name mysql-service -v d:/mysql/data:/var/lib/mysql -p "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("3306")]),s._v(":3306 -e "),a("span",{pre:!0,attrs:{class:"token assign-left variable"}},[s._v("MYSQL_ROOT_PASSWORD")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("123456")]),s._v(" -d mysql:5.7c\n")])])]),a("p",[s._v("小贴士：你可以通过 SHOW VARIABLES LIKE 'character%' 查看字符集是否更改为utf8mb4,也可以通过SHOW VARIABLES LIKE '%time_zone%' 查看时区是否是东八区。")]),s._v(" "),a("h2",{attrs:{id:"docker-的宿主系统是-centos-为什么可以运行-ubuntu-的镜像呢"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#docker-的宿主系统是-centos-为什么可以运行-ubuntu-的镜像呢"}},[s._v("#")]),s._v(" docker 的宿主系统是 centos ，为什么可以运行 ubuntu 的镜像呢？")]),s._v(" "),a("p",[s._v("首先需要区分 Linux 内核与 Linux 发行版")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("Linux 内核是 Linux 操作系统的核心, 负责硬件管理, 比如管理内存、管理磁盘（文件系统）、管理 CPU（进程）等等 ...")])]),s._v(" "),a("li",[a("p",[s._v("Linux 发行版是在 Linux 内核的基础上添加了一些工具软件，比如图形界面、函数库、软件包管理系统等等 ...")])])]),s._v(" "),a("p",[s._v("CentOS 与 Ubuntu 是不同的 Linux 发行版, 它们都是基于 Linux 内核， 只是添加的工具软件不同。比如， 他们的软件包管理系统不同， CentOS 使用 yum 命令安装软件， 而 Ubuntu 使用 apt-get 命令安装软件。")]),s._v(" "),a("p",[s._v("因此 CentOS 与 Ubuntu 的内核是相同的（版本可能不同），只是所安装的软件不同，即文件系统不同。")]),s._v(" "),a("p",[s._v("Docker 容器技术是基于 Linux 内核实现的， 它主要用到了两个内核模块：")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("Namespace： 用于容器的隔离，例如 PID Namespace 使得容器中的进程无法感知宿主机以及其他容器中的进程。")])]),s._v(" "),a("li",[a("p",[s._v("Cgroups：用于容器的资源控制，比如限制容器所使用的内存大小或者 CPU 个数。")])])]),s._v(" "),a("p",[s._v("在 CentOS 上运行基于 Ubuntu 镜像的容器时，容器使用了 CentOS 主机的内核以及 Ubuntu 镜像，Ubuntu 镜像中安装了 Ubuntu 的各种软件（apt-get）。")]),s._v(" "),a("h2",{attrs:{id:"_2-获取镜像"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-获取镜像"}},[s._v("#")]),s._v(" 2. 获取镜像")]),s._v(" "),a("p",[s._v("除了 "),a("code",[s._v("docker images")]),s._v(" 列表中的信息，还可以通过 "),a("strong",[s._v("docker inspect")]),s._v(" 命令获得镜像更详细的信息（一大堆信息）：")]),s._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[s._v("docker inspect nginx:stable\n")])])]),a("p",[a("strong",[s._v("docker inspect")]),s._v(" 还可以使用 ID，而且只要具有唯一性，可以只给出镜像 ID 的前 N 位即可。")]),s._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[s._v("docker inspect 82e97ab0390\n")])])]),a("p",[a("strong",[s._v("docker inspect")]),s._v(" 返回的结果是 JSON 格式字符串，如果只想得到其中某部分信息，可进行过滤：")]),s._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[s._v("docker inspect -f "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('".Size"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v(" 82e97a\n")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);