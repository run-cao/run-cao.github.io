(window.webpackJsonp=window.webpackJsonp||[]).push([[339],{813:function(e,v,s){"use strict";s.r(v);var _=s(62),i=Object(_.a)({},(function(){var e=this,v=e.$createElement,s=e._self._c||v;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"redis-集群"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis-集群"}},[e._v("#")]),e._v(" Redis 集群")]),e._v(" "),s("h2",{attrs:{id:"关于集群方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关于集群方案"}},[e._v("#")]),e._v(" 关于集群方案")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("主从同步是 Redis 哨兵模式的基础；")])]),e._v(" "),s("li",[s("p",[e._v("Redis 哨兵模式是 Redis 3.0 之前的集群方案；")])]),e._v(" "),s("li",[s("p",[e._v("Redis Cluster 是 Redis 3.0 版本推出的 Redis 集群方案。")])])]),e._v(" "),s("p",[e._v("各自优缺点：")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("主从同步方案的最大缺点在于：主机挂掉之后，需要人工干预，才能将某个从机提升为主机。它并非一个 “全自动” 方案，需要人工干预。")])]),e._v(" "),s("li",[s("p",[e._v("Redis 哨兵模式解决了主从同步方案的缺点，实现了 “自动化” ，但是它的缺点在于每一个 Redis 节点中都存储的是全部的数据，"),s("small",[e._v("（相较于后来出现的 Redis Cluster 方案而言）")]),e._v("它的内存开销较大。")])]),e._v(" "),s("li",[s("p",[e._v("Redis Cluster 方案中每个 Redis 节点存储的是部分数据，所以，理论上而言，它在性能上要付出一点代价。")])])]),e._v(" "),s("h2",{attrs:{id:"_1-redis-主从同步"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-redis-主从同步"}},[e._v("#")]),e._v(" 1. Redis 主从同步")]),e._v(" "),s("p",[e._v("主从同步"),s("small",[e._v("（也叫主从复制）")]),e._v("是 Redis 高可用服务的基石，也是多机运行中最基础的一个。我们把主要存储数据的节点叫做主节点 (master），把其他通过复制主节点数据的副本节点叫做从节点 (slave），如下图所示：")]),e._v(" "),s("p",[e._v("[redis-master-slaver-01.png]")]),e._v(" "),s("p",[e._v("在 Redis 中一个主节点可以拥有多个从节点，一个从节点也可以是其他服务器的主节点，如下图所示：")]),e._v(" "),s("p",[e._v("[redis-master-slaver-02.png]")]),e._v(" "),s("p",[e._v("主从同步具有以下三个优点：")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("性能方面：有了主从同步之后，可以把查询任务分配给从服务器，用主服务器来执行写操作，这样极大的提高了程序运行的效率，把所有压力分摊到各个服务器了；")])]),e._v(" "),s("li",[s("p",[e._v("高可用：当有了主从同步之后，当主服务器节点宕机之后，可以很迅速的把从节点提升为主节点，为 Redis 服务器的宕机恢复节省了宝贵的时间；")])]),e._v(" "),s("li",[s("p",[e._v("防止数据丢失：当主服务器磁盘坏掉之后，其他从服务器还保留着相关的数据，不至于数据全部丢失。")])])]),e._v(" "),s("p",[e._v("主从复制的简单流程介绍：")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("Master 可以拥有多个 slave 。")])]),e._v(" "),s("li",[s("p",[e._v("多个 slave 可以连接同一个 Master 外，还可以连接到其他的 slave 。")])]),e._v(" "),s("li",[s("p",[e._v("主从复制不会阻塞 Master 在主从复制时，Master 可以处理 client 请求。")])]),e._v(" "),s("li",[s("p",[e._v("提供系统的伸缩性。")])])]),e._v(" "),s("p",[e._v("主从复制简单原理的过程：")]),e._v(" "),s("ol",[s("li",[s("p",[e._v("slave 与 Master 建立连接，发送 sync 同步命令。 也就是说当用户在 Master 写入一条命令后，他们之间会通过一些算法把数据同步到每一个 slave 上。")])]),e._v(" "),s("li",[s("p",[e._v("Msater 会开启一个后台进程，将数据库快照保存到文件中。同时 Master 主进程会开始收集新的写命令并缓存。")])]),e._v(" "),s("li",[s("p",[e._v("后台完成保存后，就将文件发送给 slave 。")])]),e._v(" "),s("li",[s("p",[e._v("slave 将此文件保存在硬盘上。")])])]),e._v(" "),s("h2",{attrs:{id:"redis-sentinel-哨兵-模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis-sentinel-哨兵-模式"}},[e._v("#")]),e._v(" Redis Sentinel（哨兵）模式")]),e._v(" "),s("p",[e._v("之前有提到过，主从复制模式存在一个致命的问题，当主节点奔溃之后，需要人工干预才能恢复 Redis 的正常使用。")]),e._v(" "),s("p",[e._v("假设，有 A"),s("small",[e._v("（主）")]),e._v("、B、C 三台服务器组成的一个主从复制集群，当 A 发生故障时，你要做的事情有：")]),e._v(" "),s("ol",[s("li",[e._v("把 B 服务器设置成主服务器；")]),e._v(" "),s("li",[e._v("设置"),s("small",[e._v("（或保持）")]),e._v("C 服务器为从服务器，但是要重新配置它从 B 服务同步数据；")]),e._v(" "),s("li",[e._v("重启、努力恢复 A 服务器的执行，一旦恢复成功，设置它为从服务器，并配置它从 B 服务器同步数据。")])]),e._v(" "),s("p",[e._v("一旦这个事情发生在晚上或者从服务器节点很多的情况下，对于人工来说，这就是一件很麻烦的事情。")]),e._v(" "),s("p",[e._v("Redis Sentinel（哨兵模式）来把手动的过程变成自动的，让 Redis 拥有自动容灾恢复"),s("small",[e._v("（failover）")]),e._v("的能力的 “自动化” 工具。")]),e._v(" "),s("p",[e._v("哨兵模式如下所示：")]),e._v(" "),s("p",[e._v("[redis-sentinel-01.png]")]),e._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[e._v("小贴士")]),e._v(" "),s("p",[e._v("Redis Sentinel 的最小分配单位是一主一从。")])]),e._v(" "),s("p",[e._v("如果你担心哨兵节点发生故障，无法起到监视的作用，你可以配置多个哨兵，就像这样：")]),e._v(" "),s("p",[e._v("[redis-sentinel-02.png]")]),e._v(" "),s("p",[e._v("通常情况下哨兵节点"),s("small",[e._v("（即，sentinel 集群）")]),e._v("的数量取大于 1 的奇数，例如 3、5、7、9 。")]),e._v(" "),s("p",[e._v("Sentinel 工作方式：")]),e._v(" "),s("ul",[s("li",[s("p",[e._v("每个 Sentinel 以每秒钟一次的频率向它所知的 Master，Slave 以及其他 Sentinel 实例发送一个 PING 命令。")])]),e._v(" "),s("li",[s("p",[e._v("如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 "),s("em",[e._v("down-after-milliseconds")]),e._v(" 选项所指定的值， 则这个实例会被 Sentinel 标记为主观下线。")])]),e._v(" "),s("li",[s("p",[e._v("如果一个 Master 被标记为主观下线，则正在监视这个 Master 的所有 Sentinel 要以每秒一次的频率确认 Master 的确进入了主观下线状态。")])]),e._v(" "),s("li",[s("p",[e._v("当有足够数量的 Sentinel"),s("small",[e._v("（大于等于配置文件指定的值）")]),e._v("在指定的时间范围内确认 Master 的确进入了主观下线状态， 则 Master 会被标记为客观下线。")])]),e._v(" "),s("li",[s("p",[e._v("在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有 Master，Slave 发送 INFO 命令。")])]),e._v(" "),s("li",[s("p",[e._v("当 Master 被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次。")])]),e._v(" "),s("li",[s("p",[e._v("若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会被移除。")])]),e._v(" "),s("li",[s("p",[e._v("若 Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。")])])]),e._v(" "),s("p",[s("img",{attrs:{src:"https://hemiao3000.gitee.io/java-note-img/images/redis/img/redis-cluster-01.png",alt:"redis-cluster-01"}})])])}),[],!1,null,null,null);v.default=i.exports}}]);